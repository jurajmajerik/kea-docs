---
slug: kea-3.0
title: 'Kea 3.0: Logic Builders'
author: Marius Andra
author_title: Kea Core Team
author_url: https://github.com/mariusandra
author_image_url: https://avatars1.githubusercontent.com/u/53387?v=4
tags: [kea, release]
---

If you're reading this, then it means we have released Kea 3.0. :tada:

While 99% backwards compatible (see below), version 3.0 brings a whole new level of clarity and composability to Kea,
comparable to what Hooks did to React.

Instead of passing an object to `kea({ actions: ... })` like before, you now pass an **array of logic builders**:

```ts
import { kea, actions, reducers, listeners } from 'kea'

export const githubLogic = kea([
    actions({
        setUsername: (username: string) => ({ username }),
    }),
    reducers({
        username: [
            'keajs',
            {
                setUsername: (_, { username }) => username,
            },
        ],
    }),
    listeners(({ actions }) => ({
        setUsername: async ({ username }) => {
            console.log('username changed', { username })
        },
    })),
])
```

Each **logic builder** is a simple function that modifies the `logic`:

```ts
function actions<L extends Logic = Logic>(input): LogicBuilder<L> {
    return (logic) => {
        for (const [key, payload] of input) {
            logic.actionsCreators[key] = createAction(key, payload)
            logic.actions[key] = (...args: any[]) => dispatch(logic.actionsCreators[key](...args))
            // etc...
        }
    }
}
```

Why is this cool?

In one word: composability.

Suppose you're a big fan of the `username` + `setUsername` setter pattern and would like to abstract away the details? Easy!

```ts
import { kea, actions, reducers, listeners, BreakPointFunction } from 'kea'

interface SettersInput {
    [string]: [value: any, onChange?: (value: any, breakpoint: BreakPointFunction) => void]
}

function setters<L extends Logic = Logic>(
    input: SettersInput | ((logic: BuiltLogic<L>) => SettersInput)
): LogicBuilder<L> {
    return (logic) => {
        const setters = typeof input === 'function' ? input(logic) : input
        for (const [key, [value, onChange]] of setters) {
            actions({ [`set${capitalize(key)}`]: (value) => ({ [key]: value }) })(logic)
            reducers({ [key]: [value, { [`set${capitalize(key)}`]: (_, payload) => payload[key] }] })(logic)
            onChange && listeners({ [key]: (payload, breakpoint) => onChange(payload[key], breakpoint) })(logic)
        }
    }
}

export const githubLogic = kea([
    setters({
        username: [
            'keajs',
            (username) => {
                console.log('Username changed:', username)
            },
        ],
    }),
])

githubLogic.mount()
githubLogic.actions.setUsername('posthog')
// [console.log] Username changed: posthog
githubLogic.values.username === 'posthog'
```

The sky is the limit.

This is exactly how the [kea-forms](https://github.com/keajs/kea-forms/blob/kea-3.0/src/builder.ts#L16) and [kea-loaders](https://github.com/keajs/kea-loaders/blob/kea-3.0/src/index.ts#L86) plugins work internally: they just add a bunch of actions, reducers, listeners and selectors onto an existing logic.
